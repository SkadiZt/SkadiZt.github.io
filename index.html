<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Skadi&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Skadi&#39;s blog">
<meta property="og:url" content="https://skadizt.github.io/index.html">
<meta property="og:site_name" content="Skadi&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SkadiZt">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Skadi's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Skadi&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">摸鱼产出</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://SkadiZt.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-test" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/09/test/" class="article-date">
  <time class="dt-published" datetime="2023-07-09T08:19:10.000Z" itemprop="datePublished">2023-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/09/test/">test</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><h3 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h3><h4 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h4><h4 id="os"><a href="#os" class="headerlink" title="os"></a>os</h4><ol>
<li>基本特征：并发（并行需要硬件支持）；共享（互斥&amp;同时）；虚拟（时分复用&amp;空分复用）；异步</li>
<li>基本功能：进程管理；内存管理；文件管理；设备管理</li>
<li>系统调用：用户态-&gt;内核态。linux有进程控制，进程通信，文件操作，设备操作，信息维护，安全。</li>
<li>宏内核和微内核。只有微内核这一个模块运行在内核态，其余模块运行在用户态。</li>
<li>中断：外中断；异常；陷入。</li>
</ol>
<h5 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h5><p>进程是资源分配的基本单位。<br>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态。<br>线程是独立调度的基本单位。<br>一个进程中可以有多个线程，它们共享进程资源。<br>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。<br>进程通信（IPC）：管道，命名管道（FIFO），消息队列，共享内存，信号，信号量，socket。</p>
<p>进程状态的切换<br>就绪态，运行态，阻塞态</p>
<p>进程调度算法<br>FCFS<br>SJF<br>SRTN<br>RR<br>优先级调度<br>多级反馈队列</p>
<p>进程同步<br>对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。<br>信号量。互斥量。<br>管程？<br>生产者和消费者。哲学家进餐。读者-写者。</p>
<p>进程通信</p>
<ol>
<li>管道。只支持半双工通信（单向交替传输）；只能在父子进程或者兄弟进程中使用。</li>
<li>FIFO。也称为命名管道，去除了管道只能在父子进程中使用的限制。</li>
<li>消息队列。消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
<li>信号量。</li>
<li>共享存储（共享内存）。</li>
<li>套接字。</li>
</ol>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>死锁条件</p>
<ol>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ol>
<p>处理方法</p>
<ol>
<li>鸵鸟策略。开摆。</li>
<li>死锁检测与死锁恢复。不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</li>
<li>死锁预防。在程序运行之前预防发生死锁。</li>
<li>死锁避免。在程序运行时避免发生死锁。银行家算法。</li>
</ol>
<h5 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h5><p>虚拟内存<br>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。<br>虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p>
<h5 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h5><h4 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h4><p>应用层<br>表示层<br>会话层<br>传输层<br>网络层<br>数据链路层<br>物理层</p>
<h5 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h5><p>请求和相应报文<br>URL-Uniform Resource Locator</p>
<ul>
<li>方法</li>
</ul>
<ol>
<li>GET</li>
<li>HEAD</li>
<li>POST-比GET安全</li>
<li>PUT-上传文件，不安全</li>
<li>PATCH-部分修改资源</li>
<li>DELETE-PUT相反，同不安全</li>
<li>OPTIONS-查询支持方法</li>
<li>CONNECT-要求在与代理服务器通信时建立隧道</li>
<li>TRACE-追踪路径</li>
</ol>
<ul>
<li>状态码<br>服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</li>
</ul>
<ol>
<li>1XX 信息</li>
<li>2XX 成功</li>
<li>3XX 重定向</li>
<li>4XX 客户端错误</li>
<li>5XX 服务器错误</li>
</ol>
<ul>
<li><p>HTTP 首部<br>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>
</li>
<li><p>具体应用</p>
</li>
</ul>
<ol>
<li><p>短连接与长连接。<br>从HTTP&#x2F;1.1开始默认是长连接的，之前默认短链接。</p>
</li>
<li><p>流水线<br>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p>
</li>
<li><p>Cookie-不够安全<br>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。<br>服务器发送给浏览器，浏览器保存到本地，每次请求都会需要携带 Cookie 数据。<br>但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。<br>会话状态管理；个性化设置；浏览器行为跟踪<br>过程：响应报文包含 Set-Cookie 首部字段；通过 Cookie 请求首部字段发送给服务器。<br>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。<br>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。.<br>作用域：Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。<br>JavaScript-通过 document.cookie可访问访问非 HttpOnly 标记的 Cookie。<br>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。<br>可以将 Cookie 值进行加密，然后在服务器进行解密</p>
</li>
<li><p>Session-更加安全<br>存储在服务器端-redis</p>
</li>
<li><p>缓存</p>
</li>
</ol>
<ul>
<li><p>优点<br>缓解服务器压力；<br>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</p>
</li>
<li><p>实现<br>让代理服务器进行缓存；<br>让客户端浏览器进行缓存。</p>
</li>
</ul>
<ol start="6">
<li><p>虚拟主机<br>HTTP&#x2F;1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p>
</li>
<li><p>通信数据转发<br>代理<br>网关<br>隧道</p>
</li>
</ol>
<ul>
<li>HTTPS-速度慢，证书贵<br>HTTP 有以下安全性问题：</li>
</ul>
<ol>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ol>
<p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。<br>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<p>加密：</p>
<ol>
<li>对称密钥加密-速度快，无法安全地将密钥传输给通信方</li>
<li>非对称密钥加密-加密和解密使用不同的密钥。</li>
<li>HTTPS 采用的加密方式-使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。</li>
</ol>
<p>认证<br>通过使用 证书 来对通信方进行认证。<br>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>完整性保护</p>
<ul>
<li>HTTP&#x2F;2.0</li>
</ul>
<ol>
<li><p>HTTP&#x2F;1.x 缺陷<br>HTTP&#x2F;1.x 实现简单是以牺牲性能为代价的：<br>客户端需要使用多个连接才能实现并发和缩短延迟；<br>不会压缩请求和响应首部，从而导致不必要的网络流量；<br>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</p>
</li>
<li><p>二进制分帧层</p>
</li>
<li><p>服务端推送</p>
</li>
<li><p>首部压缩</p>
</li>
<li><p>多路复用</p>
</li>
</ol>
<ul>
<li>HTTP&#x2F;1.1 新特性 总结<br>默认是长连接<br>支持流水线<br>支持同时打开多个 TCP 连接<br>支持虚拟主机<br>新增状态码 100<br>支持分块传输编码<br>新增缓存处理指令 max-age</li>
</ul>
<h5 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h5><p>阻塞式 I&#x2F;O<br>非阻塞式 I&#x2F;O-轮询<br>I&#x2F;O 复用（select 和 poll）-单个进程具有处理多个 I&#x2F;O 事件的能力，减小开销<br>信号驱动式 I&#x2F;O（SIGIO）<br>异步 I&#x2F;O（AIO）</p>
<p>I&#x2F;O 复用</p>
<ol>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ol>
<h4 id="db"><a href="#db" class="headerlink" title="db"></a>db</h4><ul>
<li>事务-满足acid的一组操作，不可分割的最小单元<br>ACID</li>
</ul>
<ol>
<li>原子性（Atomicity）-事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
<li>一致性（Consistency）-数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</li>
<li>隔离性（Isolation）-一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
<li>持久性（Durability）-一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。<br>原子性和隔离性保证了一致性；持久性应对系统崩溃。<br>MySQL 默认采用自动提交模式。</li>
</ol>
<ul>
<li>并发一致性问题<br>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</li>
</ul>
<ol>
<li>丢失修改<br>后修改的事务覆盖率之前事务的修改。</li>
<li>脏读<br>读到其他事务尚未提交的数据。</li>
<li>不可重复读<br>事务读取同一数据，两次数据不一致。</li>
<li>幻读<br>类似不可重复读，事务查找一定范围，两次查找结果的结果数量不一致。<br>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</li>
</ol>
<ul>
<li>封锁</li>
</ul>
<ol>
<li>封锁粒度<br>行级锁和表级锁<br>封锁粒度越小，系统开销就越大。</li>
<li>封锁类型<br>读写锁：<br>互斥锁（Exclusive），简写为 X 锁，又称写锁。<br>共享锁（Shared），简写为 S 锁，又称读锁。<br>S与S兼容，X不与任何兼容。<br>意向锁：<br>意向锁在原来的 X&#x2F;S 锁之上引入了 IX&#x2F;IS，IX&#x2F;IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。<br>有以下两个规定：1.一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；2.一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。<br>x不与任何兼容；IX不与X&#x2F;S兼容，S不与X,IX兼容，IS不与X兼容<br>任意 IS&#x2F;IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；这里兼容关系针对的是表级锁；</li>
<li>封锁协议<br>三级封锁协议：<blockquote>
<p>一级封锁协议:事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。可以解决丢失修改问题<br>二级封锁协议:在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。可以解决读脏数据问题<br>三级封锁协议:在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。可以解决不可重复读的问题</p>
</blockquote>
</li>
</ol>
<p>两段锁协议（2pl）<br>加锁和解锁分为两个阶段进行。</p>
<ul>
<li>隔离级别</li>
</ul>
<ol>
<li>未提交读（READ UNCOMMITTED）<br>事务中的修改，即使没有提交，对其它事务也是可见的。</li>
<li>提交读（READ COMMITTED）-脏读<br>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li>
<li>可重复读（REPEATABLE READ）-不可重复读<br>保证在同一个事务中多次读取同一数据的结果是一样的。</li>
<li>可串行化（SERIALIZABLE）-幻读<br>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。<br>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</li>
</ol>
<ul>
<li>多版本并发控制<br>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。<br>MVCC+Next-Key Locks可以解决幻读。<br>MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。<br>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。<br>MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</li>
</ul>
<ol>
<li>Undo 日志<br>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</li>
<li>ReadView<br>TRX_ID_MIN &lt;&#x3D; TRX_ID &lt;&#x3D; TRX_ID_MAX，需要根据隔离级别再进行判断：<br>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。<br>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
<li>快照读与当前读<br>SELECT 操作是快照中的数据，不需要进行加锁操作。其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。<br>可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。当前读存在幻读的问题。</li>
</ol>
<ul>
<li>Next-Key Locks<br>在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。<br>是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。</li>
</ul>
<ol>
<li>Record Locks<br>锁定一个记录上的索引，而不是记录本身。</li>
<li>Gap Locks<br>锁定索引之间的间隙，但是不包含索引本身。阻止插入。</li>
</ol>
<ul>
<li>关系数据库设计理论</li>
</ul>
<ol>
<li>函数依赖<br>部分，完全，传递</li>
<li>异常<br>冗余数据；修改异常；删除异常；删除异常。</li>
<li>范式<br>范式理论是为了解决以上提到四种异常。<br>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。<blockquote>
<ol>
<li>第一范式 (1NF):属性不可分。2. 第二范式 (2NF):每个非主属性完全函数依赖于键码。3.第三范式 (3NF):非主属性不传递函数依赖于键码。<br>4.BCNF:所有非主属性对每一个候选键都是完全函数依赖； 所有的主属性对每一个不包含它的候选键，也是完全函数依赖；没有任何属性完全函数依赖于非候选键的任何一组属性。</li>
</ol>
</blockquote>
</li>
</ol>
<ul>
<li>ER图</li>
</ul>
<h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h5><ul>
<li>索引</li>
</ul>
<ol>
<li>B+树。<br>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。<br>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。<br>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。<br>递归的进行二分查找，直到叶子节点上二分查找找到目标key。<br>性能优势：<br>1.B+ 树有更低的树高。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大。<br>2.磁盘访问原理。进行寻道的次数与树高成正比。<br>3.进行寻道的次数与树高成正比。磁盘每次都会预读。预读过程中，磁盘进行顺序读取。<br>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。<br>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</li>
<li>哈希索引-自适应哈希索引。时间复杂度o(1)。</li>
<li>全文索引-不懂。</li>
<li>索引优化<br>索引需要是独立的列。<br>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。<br>让选择性最强的索引列放在前面。<br>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。<br>覆盖索引-包含所有需要查询的字段的值。1.包含所有需要查询的字段的值。2.一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。不需要回表。3.一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>索引的优点<br>大大减少了服务器需要扫描的数据行数。<br>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。<br>将随机 I&#x2F;O 变为顺序 I&#x2F;O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li>
<li>索引的使用条件<br>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；<br>对于中到大型的表，索引就非常有效；<br>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
<li>索引覆盖<br>普通索引（二级索引）存在回表。<br>将被查询的字段，建立到联合索引里去，从而避免回表。<br>可以利用索引覆盖来优化SQL：</li>
</ol>
<ul>
<li><p>查询优化<br>优化数据访问：<br>1.减少请求的数据量。只返回必要的列：最好不要使用 SELECT * 语句。只返回必要的行：使用 LIMIT 语句来限制返回的数据。缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。<br>2.减少服务器端扫描的行数。最有效的方式是使用索引来覆盖查询。<br>重构查询方式：<br>1.切分大查询<br>2.分解大连接查询</p>
</li>
<li><p>存储引擎</p>
</li>
</ul>
<ol>
<li>InnoDB-默认引擎，默认rr</li>
<li>MyISAM-不支持事务。不支持行级锁。可以手工或者自动执行检查和修复操作。</li>
</ol>
<ul>
<li>复制<br>主从复制<br>涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。<br>数据备份+读写分离。</li>
</ul>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ol>
<li>单例模式<br>确保一个类只有一个实例，并提供该实例的全局访问点。<br>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。<br>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</li>
</ol>
<ul>
<li><p>懒汉式<br>实现方式：a. 静态指针 + 用到时初始化；b. 局部静态变量（善）<br>懒汉模式的特点是延迟加载。在第一次用到类实例的时候才会去实例化。<br>注意线程不安全和内存泄漏。此外析构顺序未知可能会造成错误？<br>改进1：对公有函数加锁。<br>改进2：双重校验锁。双重校验锁先判断公有静态函数是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。<br>改进3：共享指针。</p>
</li>
<li><p>饿汉式<br>实现方式：a.直接定义静态对象；b. 静态指针 + 类外初始化时new空间实现<br>单例类定义的时候就进行实例化。</p>
</li>
</ul>
<ol start="2">
<li>工厂模式<br>定义一个创建对象的接口，让子类决定实例化哪个类，而对象的创建统一交由工厂去生产，有良好的封装性，既做到了解耦，也保证了最少知识原则。<br>工厂模式属于创建型模式，大致可以分为三类，简单工厂模式、工厂方法模式、抽象工厂模式。</li>
</ol>
<ul>
<li><p>简单工厂模式<br>把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。<br>缺点：要增加新的核类型时，就需要修改工厂类。</p>
</li>
<li><p>工厂方法模式<br>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。<br>缺点：需要更多的类定义。</p>
</li>
<li><p>抽象工厂模式<br>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>缺点：扩展不方便。</p>
</li>
</ul>
<h3 id="面经问题总和"><a href="#面经问题总和" class="headerlink" title="面经问题总和"></a>面经问题总和</h3><h4 id="华科人问题"><a href="#华科人问题" class="headerlink" title="华科人问题"></a>华科人问题</h4><p>1、面向对象的三大特性：封装、继承、多态<br>2、类的访问权限：private、protected、public<br>3、类的构造函数、析构函数、赋值函数、拷贝函数<br>4、移动构造函数与拷贝构造函数对比<br>改变指针指向空间从属，减少消耗，用浅拷贝。<br>5、深拷贝与浅拷贝的区别<br>指针。<br>6、空类有哪些函数？空类的大小？<br>缺省构造，拷贝构造，析构，赋值重载，取地址重载，const修饰取地址重载。占一字节以分配空间。<br>7、内存分区：全局区、堆区、栈区、常量区、代码区<br>代码段，数据段，bss段，堆区，栈区<br>8、C++与C的区别<br>面向对象。<br>9、struct与class的区别<br>默认public，用途，等等<br>10、struct内存对齐<br>避免访问一个结构体变量需要两次寻址。cpu每次读取一定长度的内存。<br>11、new&#x2F;delete与malloc&#x2F;free的区别<br>前者是关键字，后者是函数。<br>前者可为非内部类型的对象分配空间。<br>12、内存泄露的情况<br>new了没有delete<br>指针嵌套时释放<br>缺少拷贝构造函数<br>缺少重载赋值运算符-指针成员<br>没有将基类的析构函数定义为虚函数<br>13、sizeof与strlen对比<br>sizeof运算符，都能算字节大小<br>strlen函数，字符串长度<br>14、指针与引用的区别<br>引用是别名<br>15、野指针产生与避免<br>指针未初始化<br>指向对象已经释放<br>指针释放后未置空<br>可以用引用代替指针，注意操作规范，避免重复指向同一空间。<br>16、多态：动态多态、静态多态<br>动态：派生类，虚函数<br>静态：函数重载，模板函数<br>17、虚函数实现动态多态的原理、虚函数与纯虚函数的区别</p>
<p>18、继承时，父类的析构函数是否为虚函数？构造函数能不能为虚函数？为什么？<br>19、静态多态：重写、重载、模板<br>20、static关键字：修饰局部变量、全局变量、类中成员变量、类中成员函数<br>21、const关键字：修饰变量、指针、类对象、类中成员函数<br>22、extern关键字：修饰全局变量<br>23、volatile关键字：避免编译器指令优化<br>24、四种类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast<br>25、右值引用<br>26、std::move函数<br>27、四种智能指针及底层实现：auto_ptr、unique_ptr、shared_ptr、weak_ptr<br>28、shared_ptr中的循环引用怎么解决？（weak_ptr）<br>29、vector与list比较<br>30、vector迭代器失效的情况<br>31、map与unordered_map对比<br>32、set与unordered_set对比<br>33、STL容器空间配置器  </p>
<h4 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h4><p>双重校验锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singleton *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pInstance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mute.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (pInstance == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pInstance = <span class="keyword">new</span> singleton;</span><br><span class="line">            &#125;</span><br><span class="line">            mute.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="type">static</span> singleton *pInstance;</span><br><span class="line">    <span class="type">static</span> mutex mute;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>饿汉式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstatce</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton <span class="type">const</span> &amp; single);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp; single);</span><br><span class="line">    <span class="type">static</span> Singleton m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外初始化</span></span><br><span class="line">Singleton Singleton::m_instance;</span><br></pre></td></tr></table></figure>
<h4 id="db-1"><a href="#db-1" class="headerlink" title="db"></a>db</h4><ol>
<li>索引的数据结构对比（hash、B树与B+树），为什么不用红黑树<br>hash的优点是时间o(1)，频繁使用的索引值会建立自适应哈希索引。<br>hash的缺点是不具有有序性，无法查找和分组，无法部分查询和范围查询。<br>红黑树相对b树和b+树搜索速度更快，但是出度小，树更高，磁盘io次数多。<br>b+树是b树的优化，非叶子节点只储存key，这样一来树高更低，叶子节点之间靠指针相连接，具有有序性，也契合了磁盘预读的特性。</li>
<li>Mysql的默认隔离级别、不同等级隔离级别解决的问题与实现原理、<br>未提交读，提交读RC，可重复读RR（MySQL默认），可串行化。<br>提交读解决了脏读，不会读取到其他未提交事务的修改。<br>可重复读解决了不可重复读，在一次事务中前后查询的结果一致。<br>可串行化解决了脏读，在一次事务中前后查询的结果数目一致。<br>可以利用加锁来实现不同的隔离级别-三级封锁协议，意向锁，2pl锁云云。<br>MySQL主要使用MVCC来实现了RC和RR。</li>
<li>Mysql事务及特性<br>事务是一组不可分割的操作，具有acid特性。<br>原子性，一致性，隔离性，持久性。Redo log。</li>
<li>Mvcc实现机制(RC和RR隔离级别下的区别)<br>每行记录会有事务版本号和回滚指针。<br>系统版本号随事务递增，而每个事务的版本号是创建时的系统版本号。<br>select会新建一个ReadView来确定哪些版本的记录对于该事务是可见的。<br>对于RR，readview只会在第一次select建立。<br>而RC每次都会建立，从而导致了不可重复读。</li>
<li>Mysql的聚簇索引和非聚簇索引作用与区别<br>主键索引，唯一索引，聚簇索引。data为完整的一行记录。<br>普通索引，二级索引，非聚簇索引。data为主键。有可能需要回表查询。</li>
<li>索引失效的几种场景<br>索引列不是独立的列。<br>未满足最左匹配原则。<br>字符串未加’’。<br>表较小，自动优化为全表查询。<br>最好不要使用比较或范围。</li>
<li>Mysql sql优化，慢Sql如何排查<br>使用索引。<br>使用覆盖索引，避免回表。<br>链接查询。<br>联合查询。<br>子查询。<br>分解大查询。<br>慢查询日志。</li>
<li>Mysql的几种存储引擎<br>InnoDB<br>MyISAM</li>
<li>Mysql索引优化与设计规则<br>独立的列；多列索引；让选择性最强的索引列放在前面；前缀索引；覆盖索引。</li>
<li>Mysql的binlog redolog undolog日志文件及其作用<br>binlog-主从复制。和redolog一致？<br>redolog-保证了持久性，不会丢失数据。<br>undolog-用于实现MVCC。还有原子性。</li>
<li>简述索引作用与优缺点<br>减少了服务器需要扫描的数据行数。<br>帮助服务器避免进行排序和分组，以及避免创建临时表。<br>将随机 I&#x2F;O 变为顺序 I&#x2F;O。<br>较小的表直接进行全表查询。<br>特大的表索引开销太大，使用分区。</li>
<li>解释脏读、幻读及产生条件</li>
<li>索引的最左匹配原则</li>
<li>简述索引分类</li>
<li>数据库三范式</li>
</ol>
<h4 id="计网-1"><a href="#计网-1" class="headerlink" title="计网"></a>计网</h4><ol>
<li>Tcp与Udp区别<br>TCP 面向连接，UDP 是无连接的；<br>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付；<br>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道；<br>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信；<br>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）；<br>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）；<br>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节；</li>
<li>Http、Https、两者区别<br>http的中文叫做超文本传输协议，基于TCP。<br>https则是http+ssl。<br>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。<br>http明文传输。<br>https协议需要到ca申请证书。</li>
<li>浏览器上输入地址后的整个请求过程<br>输入地址。<br>查找对应的IP地址。<br>建立TCP链接。<br>向服务器发送请求。<br>服务器进行处理。<br>返回相应结果。<br>浏览器进行解析并渲染。</li>
<li>Tcp三次握手四次挥手及对应的状态<br><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.md#tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.md#tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B</a><br>close-wait：服务端发送完剩下的数据<br>time-wait：等待，防止发送的ack没收到，服务端超时重发</li>
<li>OSI七层、五层模型，每一层的作用<br>应用层（会话层，表示层）-应用，应用协议<br>表示层-数据格式转换及加密<br>会话层-建立通信<br>传输层-TCP、UDP，端到端，报文<br>网络层-arp，帧<br>数据链路层-硬件寻址，比特<br>物理层</li>
<li>Tcp流量控制与拥塞控制<br>流量控制，接收端维护接收窗口（滑动窗口）。<br>拥塞控制，拥塞窗口cwnd，慢启动-拥塞避免（慢开始限制）&amp;&amp;快充传+快恢复</li>
<li>Tcp如何保证可靠传输<br>超时重传机制。</li>
<li>Https的加密流程<br>建立TCP，再建立SSL&#x2F;TLS<br>非对称加密传递密钥，对称加密进行通信</li>
<li>epoll</li>
</ol>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><ol>
<li><p>dns服务器<br>纯c实现。<br>运行流程：</p>
<blockquote>
<p>手动配置本地dns服务器为localhost：53，并命令行启动输入remote dns服务器。<br>winsock2通信<br>缓存数据结构-trie tree</p>
</blockquote>
</li>
<li><p>dsl</p>
</li>
<li><p>电商平台</p>
</li>
</ol>
<h3 id="sql文法"><a href="#sql文法" class="headerlink" title="sql文法"></a>sql文法</h3><p>where不能含有聚集函数，having ！<br>链接配合on<br>判空 is null<br>where 配合 in，in 里面嵌套查询<br>limit a，b配合排序<br>sql语句的执行过程是：<br>from–&gt;where–&gt;group by –&gt;having –&gt; select— &gt;order by;</p>
<p>聚合函数针对结果集，where并不是在结果集后运行。<br>having针对结果集，把聚合函数放在having之后。</p>
<h3 id="sql题"><a href="#sql题" class="headerlink" title="sql题"></a>sql题</h3><ol>
<li><blockquote>
<ol start="595">
<li>大的国家.送</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="627">
<li>变更性别。<br>update set where;<br>case exp1 when a then b else c end &#x3D;&#x3D; case when exp1&#x3D;a<br>if(a,b,c)-类似c++的?:</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="627">
<li>变更性别。字符加引号，mod(x,2)&#x3D;&#x3D;x%2&#x3D;&#x3D;x&amp;1</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="596">
<li>超过5名学生的课.聚集函数里面加distinct</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="182">
<li>查找重复的电子邮箱。group by + having</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="196">
<li>删除重复的电子邮箱.自链接就是内连接，注意条件</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="175">
<li>组合两个表.保留null，左链接</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="181">
<li>超过经理收入的员工</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="183">
<li>从不订购的客户.左连接+is null 判空</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="184">
<li>部门工资最高的员工.where+in+子查询</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<p>！177. 第N高的薪水。mysql函数</p>
</blockquote>
</li>
<li><blockquote>
<ol start="178">
<li>分数排名.</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="180">
<li>连续出现的数字.非常不棒的做法，三表链接。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="626">
<li>换座位。难啊</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="c-1"><a href="#c-1" class="headerlink" title="c++"></a>c++</h3><p>手写构造函数<br>和strxxxx函数</p>
<h3 id="刷题，以codetop频度为复习依据"><a href="#刷题，以codetop频度为复习依据" class="headerlink" title="刷题，以codetop频度为复习依据"></a>刷题，以codetop频度为复习依据</h3><ol>
<li><blockquote>
<ol start="3">
<li>无重复字符的最长子串.<br>经典滑动窗口题。优化细节：保存各字符最后出现的下标，而非保存出现次数，跳跃式移动left</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<p>!146. LRU 缓存.不会</p>
</blockquote>
</li>
<li><blockquote>
<ol start="25">
<li>K 个一组翻转链表<br>考察细节。生疏</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="206">
<li>反转链表<br>迭代比较熟练。!递归不太熟。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="215">
<li>数组中的第K个最大元素<br>topk,快速选择&amp;建堆。<br>快速选择算是掌握了。<br>建堆过程学习，手动维护。懂了。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="103">
<li>二叉树的锯齿形层序遍历<br>层序遍历的变种？bfs+deque解决，比较优雅</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="15">
<li>三数之和<br>如何优雅高效地循环和去重？排序（起到去重的作用）加三指针，tle。将三指针改为遍历i+双指针滑动。<br>首先排序。遍历i,移动i时移动到下一个不同的数。双指针j，k。j&#x3D;i+1，二分查找确定k的初始位置。<br>非常艰难地实现。二分在这里有点多余了。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="121">
<li>买卖股票的最佳时机<br>存储已遍历序列的最小值。<br>！可拓展为dp</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="160">
<li>相交链表<br>暴力法：哈希表存储已遍历节点，每次查重。<br>双指针，优雅。不相交情况为两个指针同时指向nullptr</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol>
<li>两数之和<br>暴力法，二重循环。<br>哈希表存值，减少一重循环。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="33">
<li>搜索旋转排序数组<br>二分。分治的韵味。将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。<br>此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="200">
<li>岛屿数量<br>dfs，bfs，并查集。<br>并查集不会！</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="236">
<li>二叉树的最近公共祖先<br>递归实现。<br>！进阶做法：倍增。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="53">
<li>最大子数组和<br>因为nums[k]可以为负数，可以排除滑动窗口<br>dp,简单。注意三目运算符加括号。亦可优化空间。<br>！分治,是以线段树的基础。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="42">
<li>接雨水<br>经典问题<br>暴力，没啥说的，向左右求最高<br>两次遍历存left和right，再求每块儿的高度<br>！单调栈？不太直观<br>双指针，基于dp优化空间。对于位置left而言，它左边最大值一定是left_max，右边最大值“大于等于”right_max，这时候，如果left_max &lt; right_max成立，那么它就知道自己能存多少水了。无论右边将来会不会出现更大的right_max，都不影响这个结果。 所以当left_max &lt; right_max时，我们就希望去处理left下标，反之，我们希望去处理right下标。天才！</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="54">
<li>螺旋矩阵<br>模拟题遍历？确实！设置left,right,top,bottom四个变量进行优雅的模拟。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="23">
<li>合并K个升序链表<br>前置：21. 合并两个有序链表。很帅的递归，糟糕的迭代。<br>暴力:依次将链表与ans合并。<br>归并:分治思想。没太懂。<br>优先队列:注意priority_queue的写法，如何自定义</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="5">
<li>最长回文子串<br>dp，不好。<br>遍历中心，经典做法。<br>！manacher。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="199">
<li>二叉树的右视图<br>层序遍历，刚好。<br>也可以dfs，根右左。维护深度，保存每个深度的第一个节点。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="300">
<li>最长递增子序列<br>简单dp，n^2。<br>修改状态定义，配合二分压缩到nlogn。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="46">
<li>全排列<br>!回溯即可。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="143">
<li>重排链表<br>暴力：将链表转化为数组读取<br>！递归：<br>快慢指针分两半，逆序后半部分，合并。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="31">
<li>下一个排列<br>逆序查找，第一个不递增的数字。二分查找已遍历范围内最小的大于该数的数字，交换。后半部分排序。<br>对二分法，已然了然于心了，通晓边界条件。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="415">
<li>字符串相加<br>模拟+字符串处理。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="88">
<li>合并两个有序数组<br>直接合并后排序<br>双指针正序合并，需要辅助数组<br>双指针逆序合并，不需要辅助数组</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="20">
<li>有效的括号<br>括号匹配，用栈辅助。左括号入栈，右括号出栈。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="141">
<li>环形链表<br>暴力：哈希表储存已遍历节点<br>双指针：Floyd 判圈算法</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="92">
<li>反转链表 II<br>找到起始位置，反转之后的right-left个节点，再插回原链表。<br>头插法，似乎更合理，更简单。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<p>！56. 合并区间<br>首先排序。</p>
</blockquote>
</li>
<li><blockquote>
<ol start="129">
<li>求根节点到叶节点数字之和<br>简单dfs递归即可。<br>！亦可bfs。但感觉不是很棒。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="105">
<li>从前序与中序遍历序列构造二叉树<br>递归：较为简单。可以提前遍历一次中序遍历序列，存在哈希表中。我使用一个全局变量维护preorder游标，也可以通过子树长度确定根的下标。<br>！迭代：巧妙，但不好理解。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="41">
<li>缺失的第一个正数<br>哈希表：双n。<br>暴力遍历：时间n^2，空间1。优化，排序+二分，nlogn。不需要二分查找，可以直接遍历，看是否存在差值大于1的两正数。<br>将数组本身视为哈希（原地哈希），负数作为标记，或者置换</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="124">
<li>二叉树中的最大路径和<br>递归实现。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="101">
<li>对称二叉树<br>递归：实现较简单。<br>迭代：初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中（即a-&gt;left和b-&gt;right一起入队，其他两子树一起入队）。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="69">
<li>x 的平方根<br>暴力：二分查找平方根。<br>！数学：牛顿迭代法。看不懂。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="76">
<li>最小覆盖子串<br>滑动窗口。额外变量num，代表尚未匹配的字符数。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="112">
<li>路径总和<br>递归。<br>！迭代：两个队列bfs，分别存放下一个节点和从根到下一个节点的路径。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="113">
<li>路径总和 II<br>递归遍历，回溯。<br>迭代：bfs，需要哈希表储存节点的父节点。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="94">
<li>二叉树的中序遍历<br>递归，容易。<br>迭代，困难。curr代表现在正在处理的函数，栈里面存放途径但是尚未处理的函数。<br>额外空间，标记该节点是否已访问过。<br>！Morris 遍历算法。其实整个过程我们就多做一步：假设当前遍历到的节点为x，将x的左子树中最右边的节点的右孩子指向x，这样在左子树遍历完成后我们通过这个指向走回了x，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="32">
<li>最长有效括号<br>dp：注意corner case,不要数组越界。if(s[i]&#x3D;&#x3D;’)’&amp;&amp;s[i-1-dp[i-1]]&#x3D;&#x3D;’(‘)  dp[i]&#x3D;dp[i-1]+2+dp[i-2-dp[i-1]]<br>栈：我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标<br>对于遇到的每个’(‘ ，我们将它的下标放入栈中;对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号<br>我们在一开始的时候往栈中放入一个值为 -1 的元素.<br>常数空间：维护left和right两个变量，相等时其和即为长度，left &lt; right都置0；逆序再如此做，求最大值。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="82">
<li>删除排序链表中的重复元素 II<br>迭代：分情况讨论即可。<br>递归：也还行啊，想清楚。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="221">
<li>最大正方形<br>dp:if (matrix(i - 1, j - 1) &#x3D;&#x3D; ‘1’)     dp(i, j) &#x3D; min(dp(i - 1, j), dp(i, j - 1), dp(i - 1, j - 1)) + 1;</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="98">
<li>验证二叉搜索树<br>递归：注意维护取值范围。<br>中序遍历：中序遍历二叉搜索树，结果一定升序。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="148">
<li>排序链表<br>插入排序：o(n^2),力扣tle，维护end，注意插入到end后的情况。<br>归并排序：o(nlogn)，快慢指针找中点，归并，merge。<br>！自底向上的归并排序（未用到递归，空间o(1)）：递增sub_len。代码细节太多，要注意。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="142">
<li>环形链表 II<br>基于快慢指针判环，巧妙等量，第三个指针再次出发。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="912">
<li>排序数组<br>快排：研究下yxc这板子。关键在于do-while，确保了i和j可以保证左右数组的大小。存在i&#x3D;k-1，j&#x3D;k+1，交换后简单移动，无法判断k的大小。<br>传统的提前交换target到队列头还蛮得心应手的。<br>堆排序：具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。<br>归并排序：注意temp数组可设置为全局变量，减少析构所需时间。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="22">
<li>括号生成<br>暴力：生成所有可能组合，再检测是否有效括号对。<br>回溯：就是回溯。<br>按括号序列的长度递归：dp思想？但这题并不是很棒，保存计算结果空间开销太大。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<ol start="232">
<li>用栈实现队列</li>
</ol>
</blockquote>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://skadizt.github.io/2023/07/09/test/" data-id="cljv65qby00023olu6f1h4cza" data-title="test" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-test-my-site" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/09/test-my-site/" class="article-date">
  <time class="dt-published" datetime="2023-07-09T07:58:00.000Z" itemprop="datePublished">2023-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/09/test-my-site/">test_my_site</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://skadizt.github.io/2023/07/09/test-my-site/" data-id="cljv65qbs00003olu7wljgs5q" data-title="test_my_site" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/09/hello-world/" class="article-date">
  <time class="dt-published" datetime="2023-07-09T07:54:27.965Z" itemprop="datePublished">2023-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/09/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://skadizt.github.io/2023/07/09/hello-world/" data-id="cljv65qbv00013olugqjr9sqn" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/07/09/test/">test</a>
          </li>
        
          <li>
            <a href="/2023/07/09/test-my-site/">test_my_site</a>
          </li>
        
          <li>
            <a href="/2023/07/09/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 SkadiZt<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>